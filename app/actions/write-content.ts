"use server"

import fs from "fs/promises"
import path from "path"
import { revalidatePath } from "next/cache"
import type { PageContent } from "@/lib/content"

export async function writeContent(pageId: string, content: PageContent) {
  try {
    // Create a content object with just this page
    const contentObject = {
      [pageId]: content,
    }

    // Convert to a string that can be written to a file
    const contentString = `
// This file is auto-generated by the CMS
// Last updated: ${new Date().toISOString()}

import { cache } from "react"

export type PageContent = {
  header: {
    logo: string
    navigation: Array<{ label: string; url: string; children?: Array<{ label: string; url: string }> }>
    ctaButton: { label: string; url: string }
  }
  hero: {
    title: string
    description: string
    rating: number
    image: string
    ctaButton: { label: string; url: string }
  }
  stats: Array<{
    value: string
    label: string
    description?: string
  }>
  partners: {
    title: string
    logos: Array<{ name: string; logo: string; url?: string }>
  }
  features: {
    title: string
    description: string
    image: string
    sidebar: Array<{ title: string; isActive?: boolean }>
    items: Array<{
      title: string
      description: string
      image?: string
    }>
  }
  integrations: {
    title: string
    description: string
    logos: Array<{ name: string; logo: string }>
  }
  benefits: Array<{
    title: string
    image: string
    items: Array<{ text: string }>
  }>
  testimonials: {
    title: string
    items: Array<{
      quote: string
      author: {
        name: string
        title: string
        company: string
        avatar: string
      }
      rating: number
    }>
  }
  contact: {
    title: string
    description: string
    email: string
    mapImage: string
    ctaButton: { label: string; url: string }
  }
  footer: {
    links: Array<{ label: string; url: string }>
    copyright: string
  }
}

// Content data
const mockContent: Record<string, PageContent> = ${JSON.stringify(contentObject, null, 2)
      .replace(/"([^"]+)":/g, "$1:")
      .replace(/"/g, "'")}

// Function to get content for a specific page
export const getPageContent = cache(async (pageId: string): Promise<PageContent> => {
  // In a real implementation, this would fetch from an API
  // For now, we'll use the mock data
  const content = mockContent[pageId] || mockContent["${pageId}"]

  // Ensure all required properties exist to prevent undefined errors
  return {
    header: content.header || {
      logo: "/logo.svg",
      navigation: [],
      ctaButton: { label: "Get started", url: "/get-started" },
    },
    hero: content.hero || {
      title: "Default Title",
      description: "Default description",
      rating: 5,
      image: "/placeholder.svg",
      ctaButton: { label: "Get started", url: "/get-started" },
    },
    stats: content.stats || [],
    partners: content.partners || { title: "Partners", logos: [] },
    features: content.features || {
      title: "Features",
      description: "Our features",
      image: "/placeholder.svg",
      sidebar: [],
      items: [],
    },
    integrations: content.integrations || {
      title: "Integrations",
      description: "",
      logos: [],
    },
    benefits: content.benefits || [],
    testimonials: content.testimonials || { title: "Testimonials", items: [] },
    contact: content.contact || {
      title: "Contact Us",
      description: "",
      email: "info@example.com",
      mapImage: "/placeholder.svg",
      ctaButton: { label: "Contact", url: "/contact" },
    },
    footer: content.footer || {
      links: [],
      copyright: "Â© 2023",
    },
  }
})
`

    // Write to the content.ts file
    const contentFilePath = path.join(process.cwd(), "lib", "content.ts")
    await fs.writeFile(contentFilePath, contentString, "utf8")

    // Revalidate paths
    revalidatePath("/")
    revalidatePath(`/${pageId}`)

    return { success: true }
  } catch (error) {
    console.error("Error writing content:", error)
    return { success: false, error: (error as Error).message }
  }
}
