"use server"

import fs from "fs/promises"
import path from "path"
import { revalidatePath } from "next/cache"
import type { PageContent } from "@/lib/content"

export async function updateContentFile(pageId: string, content: PageContent) {
  try {
    console.log(`Starting content update for page: ${pageId}`)

    // Create a complete content file from scratch
    const contentFileData = `// This file is auto-generated by the CMS
// Last updated: ${new Date().toISOString()}

import { cache } from "react"

export type PageContent = {
  header: {
    logo: string
    navigation: Array<{ label: string; url: string; children?: Array<{ label: string; url: string }> }>
    ctaButton: { label: string; url: string }
  }
  hero: {
    title: string
    description: string
    rating: number
    image: string
    ctaButton: { label: string; url: string }
  }
  stats: Array<{
    value: string
    label: string
    description?: string
  }>
  partners: {
    title: string
    logos: Array<{ name: string; logo: string; url?: string }>
  }
  features: {
    title: string
    description: string
    image: string
    sidebar: Array<{ title: string; isActive?: boolean }>
    items: Array<{
      title: string
      description: string
      image?: string
    }>
  }
  integrations: {
    title: string
    description: string
    logos: Array<{ name: string; logo: string }>
  }
  benefits: Array<{
    title: string
    image: string
    items: Array<{ text: string }>
  }>
  testimonials: {
    title: string
    items: Array<{
      quote: string
      author: {
        name: string
        title: string
        company: string
        avatar: string
      }
      rating: number
    }>
  }
  contact: {
    title: string
    description: string
    email: string
    mapImage: string
    ctaButton: { label: string; url: string }
  }
  footer: {
    links: Array<{ label: string; url: string }>
    copyright: string
  }
}

// Content data
const mockContent: Record<string, PageContent> = {
  "${pageId}": ${JSON.stringify(content, null, 2)}
}

// Function to get content for a specific page
export const getPageContent = cache(async (pageId: string): Promise<PageContent> => {
  // In a real implementation, this would fetch from an API
  // For now, we'll use the mock data
  const content = mockContent[pageId] || mockContent["${pageId}"]

  // Ensure all required properties exist to prevent undefined errors
  return {
    header: content.header || {
      logo: "/logo.svg",
      navigation: [],
      ctaButton: { label: "Get started", url: "/get-started" },
    },
    hero: content.hero || {
      title: "Default Title",
      description: "Default description",
      rating: 5,
      image: "/placeholder.svg",
      ctaButton: { label: "Get started", url: "/get-started" },
    },
    stats: content.stats || [],
    partners: content.partners || { title: "Partners", logos: [] },
    features: content.features || {
      title: "Features",
      description: "Our features",
      image: "/placeholder.svg",
      sidebar: [],
      items: [],
    },
    integrations: content.integrations || {
      title: "Integrations",
      description: "",
      logos: [],
    },
    benefits: content.benefits || [],
    testimonials: content.testimonials || { title: "Testimonials", items: [] },
    contact: content.contact || {
      title: "Contact Us",
      description: "",
      email: "info@example.com",
      mapImage: "/placeholder.svg",
      ctaButton: { label: "Contact", url: "/contact" },
    },
    footer: content.footer || {
      links: [],
      copyright: "Â© 2023",
    },
  }
})`

    // Determine the file path - try multiple possible locations
    const possiblePaths = [
      path.join(process.cwd(), "lib", "content.ts"),
      path.join(process.cwd(), "src", "lib", "content.ts"),
      path.join(process.cwd(), "app", "lib", "content.ts"),
    ]

    let contentFilePath = possiblePaths[0]
    let fileExists = false

    // Check which path exists
    for (const testPath of possiblePaths) {
      try {
        await fs.access(testPath)
        contentFilePath = testPath
        fileExists = true
        console.log(`Found content file at: ${testPath}`)
        break
      } catch (error) {
        console.log(`Content file not found at: ${testPath}`)
      }
    }

    // If no file exists, create the directory structure for the first path
    if (!fileExists) {
      console.log(`No content file found. Creating new file at: ${contentFilePath}`)
      const dirPath = path.dirname(contentFilePath)

      try {
        await fs.mkdir(dirPath, { recursive: true })
        console.log(`Created directory: ${dirPath}`)
      } catch (error) {
        console.error(`Error creating directory: ${error}`)
      }
    }

    // Write the content file
    try {
      await fs.writeFile(contentFilePath, contentFileData, "utf8")
      console.log(`Successfully wrote content file to: ${contentFilePath}`)
    } catch (error) {
      console.error(`Error writing file: ${error}`)
      throw new Error(`Failed to write content file: ${(error as Error).message}`)
    }

    // Revalidate paths to refresh the content
    revalidatePath("/")
    revalidatePath(`/${pageId}`)
    console.log("Revalidated paths")

    return {
      success: true,
      message: "Content updated successfully",
      path: contentFilePath,
    }
  } catch (error) {
    console.error("Error in updateContentFile:", error)
    return {
      success: false,
      error: (error as Error).message,
      stack: (error as Error).stack,
    }
  }
}
